目录 [https://www.bilibili.com/video/BV1V4411p7EF?p=23]
=======
1. 线程实现
2. 线程状态
3. 线程同步
4. 线程通信问题
5. 高级主题

01、线程简介
-------------------
多任务-->一个人同时做两件事
多线程-->cpu多核实现和单核实现

02、 线程，进程，多线程
------------------------
**程序**是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。
**进程**是程序的一次执行过程，它是一个动态的概念。是系统分配的单位。
一个进程中可以包含若干个线程，当然一个进程中至少有一个线程。

main()函数主线程。

核心概念
------------
1. 线程就是独立的执行路径
2. 后台本身也有线程，如主线程，GC线程
3. main()主线程
4. 由调度器安排调度
5. 对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制
6. 线程会带来额外的开销，如cpu调度时间，并发控制开销
7. 每个线程在自己的工作内存交互，内存控制不当会造成数据不一致。


03、 继承Thread类
----------------------
Thread, **Runnable**, Callable
1. 生成Thread方法
	* 自定义线程类继承Thread类
	* 重写run()方法，编写线程执行体
	* 常见线程对象，调用start()方法启动线程




线程的同步
============

并发的概念
-----------
同一个对象被多个线程同时操作

线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个*对象的等待池*形成队列，等待前面线程使用完毕，下一个线程再使用。

1. 锁机制synchronized
--------------------
引起的问题：

（1） 倒置其他所有需要此锁的线程挂起

（2） 在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题

（3） 优先级倒置



2.死锁
----------------
产生死锁的四个必要条件：

（1）互斥条件：一个资源每次只能被一个进程使用

（2）请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放

（3）不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺

（4）循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系

Lock锁
---------------


