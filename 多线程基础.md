目录 [https://www.bilibili.com/video/BV1V4411p7EF?p=23]
=======
1. 线程实现
2. 线程状态
3. 线程同步
4. 线程通信问题
5. 高级主题

01、线程简介
-------------------
多任务-->一个人同时做两件事
多线程-->cpu多核实现和单核实现

02、 线程，进程，多线程
------------------------
**程序**是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。
**进程**是程序的一次执行过程，它是一个动态的概念。是系统分配的单位。
一个进程中可以包含若干个线程，当然一个进程中至少有一个线程。

main()函数主线程。

核心概念
------------
1. 线程就是独立的执行路径
2. 后台本身也有线程，如主线程，GC线程
3. main()主线程
4. 由调度器安排调度
5. 对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制
6. 线程会带来额外的开销，如cpu调度时间，并发控制开销
7. 每个线程在自己的工作内存交互，内存控制不当会造成数据不一致。


03、 继承Thread类
----------------------
Thread, **Runnable**, Callable
1. 生成Thread方法
	* 自定义线程类继承Thread类
	* 重写run()方法，编写线程执行体
	* 常见线程对象，调用start()方法启动线程




线程的同步
============

并发的概念
-----------
同一个对象被多个线程同时操作

线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个*对象的等待池*形成队列，等待前面线程使用完毕，下一个线程再使用。

1. 锁机制synchronized
--------------------
引起的问题：

（1） 倒置其他所有需要此锁的线程挂起

（2） 在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题

（3） 优先级倒置



2.死锁
----------------
产生死锁的四个必要条件：

（1）互斥条件：一个资源每次只能被一个进程使用

（2）请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放

（3）不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺

（4）循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系

Lock锁
---------------
可重入锁

ReentrantLock类实现了Lock,它拥有了与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁
```java
class A{
	private final ReentrantLock lock = new ReentrantLock();
	public void m(){
		lock.lock();
		try{
			//保证线程安全的代码;
		}
		finally{
			lock.unlock();
			//如果同步代码有异常，要将unlock()写入finally语句块
		}
	}
}
```

Lock与synchronized的区别
---------------------
* Lock是显式锁（手动开启和关闭锁）synchronized是隐式锁，出了作用域自动释放
* Lock只有代码块锁，synchronized有代码块锁和方法锁
* 使用Lock锁，JVM将花费较少的事件来调度进程，性能更好。
* 优先顺序： Lock > 同步代码块（已经进入了方法体，分配了相应资源）> 同步方法（在方法体外）


04、线程协作
=================
生产者消费者模式

生产者--->数据缓存区<---消费者
这是一个线程同步的问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件。
需要解决线程之间的通信问题：

(1) wait()------>表示线程一直等待，直到其他线程通知，与sleep不同，会释放锁

(2) wait(long timeout) -------> 指定等待的毫秒数

(3) notify() --------->唤醒一个处于等待状态的线程

(4) notifyAll()  ------------>唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度

解决方法1：管程法（数据缓存区）
解决方法2：信号灯法（标志位）


线程池
-----------------
能提高性能
* 提高响应速度
* 降低资源消耗
* 便于线程管理



