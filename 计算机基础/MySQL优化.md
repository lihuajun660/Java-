MySQL优化
===========
索引的底层结构
--------
* 为什么要设计索引？
* 如何设计索引
* 设计索引的时候使用什么数据结构
* MySQL是如何实现的

如何索引？
1. 关键值
2. 文件名称
3. 偏移量：Offset
太慢

OLAP----OLTP（Online Analysis Process）
-------------
联机分析处理
联机事务处理

MySQL存储引擎---BTREE
---------
1. InnoDB----B+树---支持自适应哈希
2. MyISAM----B+树
3. MEMORY----Hash

InnoDB实际文件
--------
frm--->存储数据的结构
ibd--->包含 1.真实数据 2.索引

磁盘中的读取过程
-----------
1. 磁盘内存的速度不匹配--->导致需要将重要的数据先加载到内存中
2. 局部性原理：发现程序和数据的访问都有聚集成群的倾向，在一个时间段内，仅适用其中一小部分（空间局部性）
或者最近访问过的程序代码和数据，很快又被访问的可能性很大（时间局部性）
3. 磁盘预读的长度一般为页page的整数倍，一页通常为4K



索引是什么？
-----------
* 索引是帮助MySQL高效获取数据的数据结构
* 索引存储在文件系统中
* 索引的文件存储形式与存储引擎有关
* 索引文件的结构
	* hash
	* 二叉树
	* B树
	* B+树

HashMap-->底层数据结构数组+链表（K-V）
Hash的缺点
1. 碰撞，扰动函数来保证散列均匀分布
2. 只能等值查询，确实很快，但是遇到范围查询就不合适了
3. 占内存

为什么不用二叉树或者红黑树
----------------------
缺点：
1. 深度太深，IO次数变多，影响数据读取效率
2. IO传输的数据不能太多（少用*）


B树
-----
1. degree度，阶--->最多放置degree-1的数据
2. 一层放慢后会将其中一元素向上移动，减少深度
3. 一个节点的数据包括
	* 键值，即表中记录的主键
	* 指针，存储子节点地址信息
	* 数据，即表中除主键外的数据
4. 一个磁盘块16KB（例：p1|16|p2|34|p3）
5. 空间浪费在存储data上了

B+树---》相比B树
----------
1. 所有的数据都放在叶子节点中
2. MySQL到底是三层还是四层？
	* 取决于数据量
3. 底层会有一个双向链表，支持从根节点开始进行随机查找（另一种为对于主键的范围查找和分页查找）
4. 排序是在存储数据的时候就在做了


前缀索引
-------
1. index_1(city(3))
只取前三个的值

mySQL-》
* InnoDB--叶子节点直接放置数据idb
* MyISAM--放置的是一个地址myD,myI文件

聚簇索引和非聚簇索引
------------------
数据和索引是否放在一起
* 放在一起，聚簇InnoDB
* 不在一起，非聚簇MyISAM 

回表
-------
select * from table where name = ?
查了两遍B+树

索引覆盖
----------
select * from table where name = ? 一定触发回表
selcet id from table where name = ?
直接找到了，索引覆盖

最左匹配
-------
**组合索引**: name, age
（name, age）类比省市区， 先会按照name去找
where name = ? and age =？
where name = ?
where age =? 
where age = ? and name=？（被优化器优化）
1, 2, 4会走索引


索引下推
--------
selcet * from table where name = ? and age = ?
 数据存储磁盘
 mysql有自己的服务，要跟磁盘发交互

**没有索引下推：**
1. 先从存储引擎中拉取数据（根据name筛选的数据）再mysql server 根据age进行数据的筛选
**有：**
1. 会在拉取数据的时候直接根据name, age 来获取数据，不需要server做任何的数据筛选
2. IO量变少了，选择IO量少的方法
3. 索引下推唯一的缺点是需要在磁盘上多做数据筛选，原来的筛选是放在内存中的，现在放到了磁盘查找数据数据的环节，这样做看起来成本比较高，但是别忘了数据排序，所有的数据是聚集存放的，所以性能不会有影响，而且整体的IO量会大大减少，反而会提升技能。

MRR？
----------
multi-range-read, 先将1000个ID值在内存中进行排序。

FIC (Fast Index Create)
-------
插入和删除数据，
1. 先创建临时表，将数据导入到临时表
2. 把原始表删除
3. 修改临时表的名字

1. 二叉树、BST（二叉搜索树）-->Binary Search Tree
2. AVL(平衡二叉树)严格平衡
左旋：逆神针旋转，父节点被右孩子取代，自己成为自己的左孩子
右旋：顺时针旋转，父节点被左孩子取代，而自己成为自己的右孩子
3. 红黑树(最高子树高度不超过最低子树两倍)---》平衡了插入和查询性能，旋转次数降低了
缺点：只有两个分支，深度太深
4. B树，多分支
5. B+树


索引匹配方式
------------------




